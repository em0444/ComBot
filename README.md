ComBot; an intelligent non-tiring fencing robot

# Custom Implementation
We developed the high-level control intelligence, safety systems, and fencing-specific algorithms from scratch. The core modules implemented by our team include:

- Kinematic Control Pipeline (arm.py, ikpy_integration.py): Designed a hybrid control architecture that combines coarse preset poses with fine-grained Inverse Kinematics targeting.
- Fencing Intelligence (fencing_actions.py, arm.py): Developed the Dynamic Target Acquisition logic (get_opponent_target), which calculates real-time coordinate transformations to track opponent vulnerabilities (e.g., chest, shoulder) regardless of their orientation.
- Localisation: Coded a particle filter algorithm from scratch using only webots components such as wheel odometry, lidar sensors and distance sensors.
- Enemy detector: Designed a simple enemy detection algorithm that gives enemy coordinates using localisation code and Webots distance sensors.
- Unintelligent strategy: Implemented several basic strategies that obtain data from either sensors or global world data depending on the controller and uses basic if trees to determine a action.
- Intelligent strategy: Trained a Deep Q network that takes in data from localisation and enemy detection and uses it to find the most optimal strategy.

# External Libraries & Pre-Programmed Assets
To ensure robust physics and mathematical accuracy, we leveraged industry-standard tools for low-level operations:

- IKPy (Inverse Kinematics Python): We utilised the ikpy library as the mathematical engine for solving the 7-DOF kinematic chain. While we designed the targets and safety constraints, the iterative inverse kinematics solver itself is provided by this package.
- Webots Controller API: Used for the low-level interface with the simulation.
- TIAGo++ Robot Model: The visual geometries and physical properties (URDF/PROTO files) are based on the standard PAL Robotics TIAGo++ platform provided by Webots.
- NumPy: Used for efficient matrix operations and coordinate frame transformations.
- Torch: Used to build neural networks, in this project a basic Deep Q network.
- MatPlotLib: Displayed debug data and created graphs for model evaluation.

This project uses `uv` for dependency management.

### 1. Prerequisites
* **Webots:** Install [Webots R2025a](https://cyberbotics.com/).
* **uv:** Install uv (The Python package manager).

### 2. Installation
Clone the repo and sync the dependencies:

```bash
uv sync
```
### 3. Run in Webots
Enter Webots preferences and change the PATH in the python command section to the path of the python binary in the .venv file inside the project generated by uv.
